# Feature Specification: UI Kit Monorepo Extraction

**Feature Branch**: `007-ui-kit-extraction`  
**Created**: 2026-01-01  
**Status**: Draft  
**Input**: User description: "Implement the core packages (types, utils, styles, ui, renderer, react-core, storage) extraction into a separate monorepo."

## Overview

Extract seven core packages from the UI Builder monorepo into a standalone `openzeppelin-ui` monorepo with independent versioning, CI/CD, and npm publishing. This enables internal OpenZeppelin products to consume these packages without the cognitive overhead of importing from a "UI Builder" namespace, while allowing faster release cycles for shared components.

### Packages to Extract

| Current Package                       | New Package Name              |
| ------------------------------------- | ----------------------------- |
| `@openzeppelin/ui-builder-types`      | `@openzeppelin/ui-types`      |
| `@openzeppelin/ui-builder-utils`      | `@openzeppelin/ui-utils`      |
| `@openzeppelin/ui-builder-styles`     | `@openzeppelin/ui-styles`     |
| `@openzeppelin/ui-builder-ui`         | `@openzeppelin/ui-components` |
| `@openzeppelin/ui-builder-renderer`   | `@openzeppelin/ui-renderer`   |
| `@openzeppelin/ui-builder-react-core` | `@openzeppelin/ui-react`      |
| `@openzeppelin/ui-builder-storage`    | `@openzeppelin/ui-storage`    |

### Package Dependency Graph

```text
ui-types (no internal deps)
    │
    ▼
ui-utils ──────────────────┐
    │                      │
    ▼                      ▼
ui-storage            ui-components
                           │
                      ┌────┴────┐
                      ▼         ▼
                ui-renderer   ui-react
                      │
                      ▼
                  ui-react
```

| Package         | Depends On                                             |
| --------------- | ------------------------------------------------------ |
| `ui-types`      | (none)                                                 |
| `ui-utils`      | `ui-types`                                             |
| `ui-styles`     | (none, CSS only)                                       |
| `ui-storage`    | `ui-utils`                                             |
| `ui-components` | `ui-types`, `ui-utils`                                 |
| `ui-renderer`   | `ui-types`, `ui-utils`, `ui-components`                |
| `ui-react`      | `ui-types`, `ui-utils`, `ui-components`, `ui-renderer` |

### Scope Boundaries

**In Scope**:

- New monorepo creation with full CI/CD pipeline
- Package migration and renaming
- UI Builder repo refactoring to consume new packages
- **Exported apps pipeline updates** (apps generated by UI Builder must use new package names)
- Basic documentation and example app
- Backward compatibility deprecated packages (optional)

**Out of Scope**:

- Adapter packages (remain in UI Builder repo)
- Storybook setup
- Comprehensive documentation site
- Breaking API changes during migration

## User Scenarios & Testing _(mandatory)_

### User Story 1 - Internal Developer Imports Packages (Priority: P1)

An OpenZeppelin developer working on a new internal product needs to use the shared UI components and types. They install packages from npm using the new `@openzeppelin/ui-*` namespace without any reference to "UI Builder" in their dependency tree.

**Why this priority**: Core value proposition - cleaner imports for internal teams, eliminates confusion about package ownership.

**Independent Test**: Developer can `pnpm add @openzeppelin/ui-types @openzeppelin/ui-components` and successfully import types and components in a fresh React project.

**Acceptance Scenarios**:

1. **Given** a new React project, **When** developer installs `@openzeppelin/ui-types`, **Then** they can import and use types without errors
2. **Given** a new React project, **When** developer installs `@openzeppelin/ui-components`, **Then** they can render Button, Input, and other components
3. **Given** packages are installed, **When** developer runs build, **Then** no TypeScript or bundler errors related to package resolution

---

### User Story 2 - Package Maintainer Releases Updates (Priority: P1)

A maintainer needs to release a bug fix or new feature to the shared packages. They create a changeset, merge to main, and packages are automatically published to npm without waiting for UI Builder app releases.

**Why this priority**: Enables independent release cadence - core packages can iterate faster than the consuming app.

**Independent Test**: Maintainer can merge a PR with changeset to the new repo and see packages published to npm within the CI pipeline.

**Acceptance Scenarios**:

1. **Given** a PR with a changeset, **When** PR is merged to main, **Then** release PR is created automatically
2. **Given** release PR is merged, **When** CI runs, **Then** affected packages are published to npm with correct versions
3. **Given** packages are published, **When** maintainer checks npm, **Then** new versions are available with provenance attestation

---

### User Story 3 - UI Builder App Continues Working (Priority: P1)

The UI Builder application continues to function correctly after the extraction, consuming the new packages from npm instead of workspace links.

**Why this priority**: Cannot break existing production application during migration.

**Independent Test**: UI Builder app builds, tests pass, and runs correctly with external package dependencies.

**Acceptance Scenarios**:

1. **Given** UI Builder repo updated to use new packages, **When** running `pnpm install`, **Then** all dependencies resolve correctly
2. **Given** dependencies are installed, **When** running `pnpm build`, **Then** app builds without errors
3. **Given** app is built, **When** running tests, **Then** all existing tests pass
4. **Given** app is running, **When** user interacts with forms, **Then** functionality matches pre-migration behavior

---

### User Story 4 - Exported Apps Use New Package Names (Priority: P1)

When a user exports a transaction form from the UI Builder, the generated standalone React application must use the new `@openzeppelin/ui-*` package names in its `package.json` dependencies. The export pipeline (PackageManager, version management, code templates) must be updated to reference the new package namespace.

**Why this priority**: Exported apps are production artifacts used by end users. If they reference non-existent or deprecated package names, the apps will fail to build when users run `npm install`.

**Independent Test**: Export a form from UI Builder and verify the generated `package.json` contains the new package names with correct versions.

**Acceptance Scenarios**:

1. **Given** UI Builder with updated export pipeline, **When** user exports a form, **Then** generated `package.json` contains `@openzeppelin/ui-renderer` instead of `@openzeppelin/ui-builder-renderer`
2. **Given** exported app with new package names, **When** user runs `npm install && npm run build`, **Then** app builds successfully
3. **Given** exported app, **When** user runs the app, **Then** form functionality works identically to pre-migration exports
4. **Given** export in different environments (local/staging/production), **When** user exports, **Then** correct version strategy is applied for each environment

---

### User Story 5 - Developer Uses Example App as Reference (Priority: P2)

A developer new to the packages wants to understand how to integrate them. They clone the example app from the new repo and run it locally to see working implementations.

**Why this priority**: Reduces onboarding friction and support burden.

**Independent Test**: Developer can clone repo, run example app, and see working component demos.

**Acceptance Scenarios**:

1. **Given** example app in repo, **When** developer runs `pnpm install && pnpm dev`, **Then** app starts without errors
2. **Given** app is running, **When** developer views it in browser, **Then** they see component examples with usage code

---

### User Story 6 - Existing Consumer Migrates Imports (Priority: P2)

A project currently using `@openzeppelin/ui-builder-*` packages needs to migrate to the new namespace. They update imports and dependencies following the migration guide.

**Why this priority**: Smooth migration path for existing consumers.

**Independent Test**: Existing project can update dependencies and imports without functionality changes.

**Acceptance Scenarios**:

1. **Given** migration guide exists, **When** developer follows steps, **Then** they can update all imports
2. **Given** consumer still has old `@openzeppelin/ui-builder-*` packages installed, **When** they attempt to update, **Then** npm shows packages are no longer maintained (404 on new versions)
3. **Given** consumer updates to new `@openzeppelin/ui-*` packages, **When** they build, **Then** identical functionality with no errors (verified by same test suite passing)

---

### Edge Cases

- What happens when a consumer has both old and new packages installed? Peer dependency conflicts should be reported clearly.
- How does the system handle a failed npm publish for one package in the release? CI should fail-fast and not publish partial releases.
- What happens when internal dependencies have version mismatches? Changesets should enforce compatible versioning through `updateInternalDependencies` setting.
- What happens when an exported app is generated during the transition period? Version management must ensure exported apps can resolve packages from npm regardless of timing.
- What happens when a bad version is published to npm? Deprecate the bad version immediately and publish a patch release with the fix.

## Requirements _(mandatory)_

### Functional Requirements

**New Monorepo Setup**:

- **FR-001**: New repository MUST use pnpm workspaces for package management
- **FR-002**: New repository MUST include changesets for version management with independent versioning per package
- **FR-003**: New repository MUST have CI pipeline that builds, tests, and lints all packages on PR
- **FR-004**: New repository MUST have release pipeline that publishes packages to npm with provenance attestation
- **FR-005**: New repository MUST include SLSA Level 3 provenance generation using `slsa-framework/slsa-github-generator` actions, producing verifiable attestations for each published npm package

**Package Migration**:

- **FR-006**: All seven packages MUST be migrated with their complete source code, tests, and configuration
- **FR-007**: Package names MUST follow the `@openzeppelin/ui-*` naming convention
- **FR-008**: Internal package dependencies MUST reference workspace packages using `workspace:^` protocol
- **FR-009**: All package exports MUST remain API-compatible with current packages. API-compatible means: (a) all existing exported functions, types, and components retain identical signatures, (b) no required parameters are added, (c) no return types are narrowed, (d) TypeScript declaration files produce no breaking type errors when consumed

**UI Builder Repo Updates**:

- **FR-010**: UI Builder MUST consume packages from npm registry, not workspace links
- **FR-011**: UI Builder CI MUST continue to pass all existing tests
- **FR-012**: UI Builder changesets configuration MUST be updated to only include builder app and adapters
- **FR-013**: Migrated package directories MUST be removed from UI Builder repo
- **FR-013a**: All `workspace:*` and `workspace:^` references to migrated packages in UI Builder MUST be replaced with npm version ranges (e.g., `^1.0.0`)

**Exported Apps Pipeline**:

- **FR-014**: PackageManager `internalPackages` Set MUST be updated to include new package names (`@openzeppelin/ui-renderer`, `@openzeppelin/ui-storage`, `@openzeppelin/ui-types`, `@openzeppelin/ui-utils`, `@openzeppelin/ui-components`, `@openzeppelin/ui-react`) replacing the old `@openzeppelin/ui-builder-*` entries
- **FR-015**: Export version management (`versions.ts`) MUST be updated with new package names and their corresponding versions
- **FR-016**: `applyVersioningStrategy` method MUST use new package name set for version resolution. Version formats by environment: local uses `file:` protocol for tarball paths, staging uses `^x.y.z-rc.n` for release candidates, production uses `^x.y.z` for stable releases
- **FR-017**: Export code templates MUST use new import paths for package references
- **FR-018**: Export testing workflow MUST verify exported apps build and run correctly with new package names
- **FR-019**: `update-renderer` and similar upgrade scripts in exported apps MUST reference new package names

**Documentation & Examples**:

- **FR-020**: New repo MUST include README with package descriptions and installation instructions
- **FR-021**: New repo MUST include a basic example React application demonstrating package usage
- **FR-022**: Migration guide MUST document steps to transition from old to new package names

**Backward Compatibility**:

- **FR-023**: Deprecated wrapper packages will NOT be published; internal consumers will migrate directly using the migration guide

**Migration Execution**:

- **FR-024**: Migration MUST follow sequential execution: new repository completed and all packages published to npm before UI Builder repository updates begin
- **FR-025**: In case of a bad npm release, the affected version MUST be deprecated using `npm deprecate` and a patch release MUST be published within the same CI run

### Key Entities

- **Package**: A publishable npm module with its own version, dependencies, and exports
- **Monorepo**: A single repository containing multiple packages with shared tooling
- **Changeset**: A file describing version bumps and changelog entries for packages
- **Release**: A coordinated npm publish of one or more packages with matching versions
- **Exported App**: A standalone React application generated by the UI Builder export system, containing package.json with dependencies on UI Kit packages

## Success Criteria _(mandatory)_

### Measurable Outcomes

- **SC-001**: All seven packages are published to npm under the new `@openzeppelin/ui-*` namespace and installable
- **SC-002**: Internal developers can integrate packages into a new project in under 15 minutes using documentation
- **SC-003**: Package releases can be published independently of UI Builder app releases (separate CI pipelines)
- **SC-004**: UI Builder application passes all existing tests with external package dependencies
- **SC-005**: New repo CI pipeline completes (build, test, lint) in under 10 minutes
- **SC-006**: Example app demonstrates at least 5 key components: Button, Input, Select, Form (from ui-components), and FormRenderer (from ui-renderer)
- **SC-007**: No "UI Builder" references remain in: README files, JSDoc comments, error messages, package.json descriptions, and TypeScript declaration file comments
- **SC-008**: Exported apps generated by UI Builder use new package names and build successfully when user runs `npm install && npm run build`
- **SC-009**: Export testing workflow (`test:export`) passes with new package configuration

## Clarifications

### Session 2026-01-01

- Q: Should packages start at 1.0.0 or continue from current versions? → A: Start all packages at 1.0.0 (clean versioning for new namespace)
- Q: Should migration be parallel or sequential? → A: Sequential (complete new repo and publish packages first, then update UI Builder in one PR)
- Q: Should deprecated wrapper packages be published under old names? → A: No, skip wrappers (internal consumers update directly via migration guide)
- Q: What should the new GitHub repository be named? → A: `openzeppelin-ui` (matches @openzeppelin/ui-\* namespace)
- Q: What is the rollback strategy for bad npm releases? → A: Deprecate bad version on npm + publish patch release immediately

## Assumptions

- All packages in the new monorepo will start at version 1.0.0 to signal a clean namespace break
- Migration follows sequential strategy: new repo complete and packages published to npm before UI Builder repo is updated
- GitHub repository `OpenZeppelin/openzeppelin-ui` can be created
- npm organization `@openzeppelin` has publishing permissions for new package names
- Existing CI secrets (NPM_TOKEN, GH_APP_ID, etc.) can be configured for new repo
- pnpm is the standard package manager across OpenZeppelin projects
- React 19 peer dependency requirement is acceptable for all packages
- SLSA provenance workflow from slsa-framework can be reused

## Dependencies

- Access to create new GitHub repository under OpenZeppelin organization
- npm publish permissions for new package names
- GitHub App credentials for automated releases
- Coordination with teams consuming current packages

## Risks

| Risk                                 | Impact | Mitigation                                                                   |
| ------------------------------------ | ------ | ---------------------------------------------------------------------------- |
| Breaking changes during migration    | High   | API compatibility testing, staged rollout                                    |
| Dual maintenance during transition   | Medium | Clear ownership, automated deprecation notices                               |
| CI/CD complexity                     | Medium | Reuse existing workflows, incremental setup                                  |
| Version drift between repos          | Low    | Renovate/Dependabot automation                                               |
| Exported apps fail during transition | High   | Coordinate package publish with export pipeline update; test export workflow |
